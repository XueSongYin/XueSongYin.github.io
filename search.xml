<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>203-MAPJOIN HINT数</title>
      <link href="/2018/12/14/MAPJOIN%20HINT/"/>
      <url>/2018/12/14/MAPJOIN%20HINT/</url>
      
        <content type="html"><![CDATA[<h3 id="MAPJOIN-HINT"><a href="#MAPJOIN-HINT" class="headerlink" title="MAPJOIN HINT"></a>MAPJOIN HINT</h3><p>当一个大表和一个或多个小表做Join时，可以使用MapJoin，性能比普通的Join要快很多。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>MapJoin 的基本原理为：在小数据量情况下，SQL会将您指定的小表全部加载到执行Join操作的程序的内存中，从而加快Join的执行速度。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>left outer join的左表必须是大表。</li><li>right outer join的右表必须是大表。</li><li>inner join左表或右表均可以作为大表。</li><li>full outer join不能使用MapJoin。</li><li>MapJoin支持小表为子查询。</li><li>使用MapJoin时，需要引用小表或是子查询时，需要引用别名。</li><li>在MapJoin中，可以使用不等值连接或者使用or连接多个条件。</li><li>目前，MaxCompute在MapJoin中最多支持指定8张小表，否则报语法错误。</li><li>如果使用MapJoin，则所有小表占用的内存总和不得超过512MB。由于MaxCompute是压缩存储，因此小表在被加载到内存后，数据大小会急剧膨胀。此处的512MB限制是加载到内存后的空间大小。</li><li>多个表Join时，最左边的两个表不能同时是MapJoin的表。</li><li>您可以通过mapjoin on 1 = 1来实现笛卡尔乘积，但请注意可能会带来计算量的膨胀。</li><li>示例如下：</li></ul><pre><code>select /* + mapjoin(a) */        a.shop_name,        b.customer_id,        b.total_price    from shop a join sale_detail b    on a.shop_name = b.shop_name;</code></pre><h3 id="不等操作"><a href="#不等操作" class="headerlink" title="不等操作"></a>不等操作</h3><p>MaxCompute SQL不支持在普通Join的on条件中使用不等值表达式，or逻辑等复杂的Join条件，但是在MapJoin中可以进行如上操作。</p><pre><code>select /*+ mapjoin(a) */        a.total_price,        b.total_price    from shop a join sale_detail b    on a.total_price &lt; b.total_price or a.total_price + b.total_price &lt; 500;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Maxcompute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maxcompute-Select </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>202-SEMI JOIN</title>
      <link href="/2018/12/13/SEMI%20JOIN/"/>
      <url>/2018/12/13/SEMI%20JOIN/</url>
      
        <content type="html"><![CDATA[<h3 id="SEMI-JOIN"><a href="#SEMI-JOIN" class="headerlink" title="SEMI JOIN"></a>SEMI JOIN</h3><p>MaxCompute支持SEMI JOIN（半连接）。SEMI JOIN中，右表只用来过滤左表的数据而不出现在结果集中。支持LEFT SEMI JOIN和LEFT ANTI JOIN两种语法。</p><h4 id="LEFT-SEMI-JOIN"><a href="#LEFT-SEMI-JOIN" class="headerlink" title="LEFT SEMI JOIN"></a>LEFT SEMI JOIN</h4><p>当Join条件成立时，返回左表中的数据。也就是mytable1中某行的Id在mytable2的所有Id中出现过，此行就保留在结果集中。</p><pre><code>SELECT * from mytable1 a LEFT SEMI JOIN mytable2 b on a.id=b.id;</code></pre><p>只会返回mytable1中的数据，只要mytable1的Id在mytable2的Id中出现。</p><h4 id="LEFT-ANTI-JOIN"><a href="#LEFT-ANTI-JOIN" class="headerlink" title="LEFT ANTI JOIN"></a>LEFT ANTI JOIN</h4><p>当Join条件不成立时，返回左表中的数据。也就是mytable1中某行的Id在mytable2的所有Id中没有出现过，此行便保留在结果集中。</p><pre><code>SELECT * from mytable1 a LEFT ANTI JOIN mytable2 b on a.id=b.id;</code></pre><p>只会返回mytable1中的数据，只要mytable1的Id在mytable2的Id没有出现。</p>]]></content>
      
      
      <categories>
          
          <category> Maxcompute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maxcompute-Select </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>201-JOIN</title>
      <link href="/2018/12/12/JOIN/"/>
      <url>/2018/12/12/JOIN/</url>
      
        <content type="html"><![CDATA[<h3 id="left-outer-join"><a href="#left-outer-join" class="headerlink" title="left outer join"></a>left outer join</h3><p>左连接，会从左表（shop）中返回所有的记录，即使在右表（sale_detail）中没有匹配的行</p><pre><code>select a.shop_name as ashop, b.shop_name as bshop from shop a        left outer join sale_detail b on a.shop_name=b.shop_name;    -- 由于表shop及sale_detail中都有shop_name列，因此需要在select子句中使用别名进行区分。</code></pre><h3 id="right-outer-join"><a href="#right-outer-join" class="headerlink" title="right outer join"></a>right outer join</h3><p>右连接，返回右表中的所有记录，即使在左表中没有记录与它匹配。</p><pre><code>select a.shop_name as ashop, b.shop_name as bshop from shop a        right outer join sale_detail b on a.shop_name=b.shop_name;</code></pre><h3 id="full-outer-join"><a href="#full-outer-join" class="headerlink" title="full outer join"></a>full outer join</h3><p>全连接，返回左右表中的所有记录。</p><pre><code>select a.shop_name as ashop, b.shop_name as bshop from shop a        full outer join sale_detail b on a.shop_name=b.shop_name;</code></pre><h3 id="inner-join"><a href="#inner-join" class="headerlink" title="inner join"></a>inner join</h3><p>在表中存在至少一个匹配时，inner join返回行。关键字inner可省略。</p><pre><code>select a.shop_name from shop a inner join sale_detail b on a.shop_name=b.shop_name;select a.shop_name from shop a join sale_detail b on a.shop_name=b.shop_name;</code></pre><h3 id="不等值连接禁止"><a href="#不等值连接禁止" class="headerlink" title="不等值连接禁止"></a>不等值连接禁止</h3><p>连接条件，只允许and连接的等值条件。只有在MAPJOIN中，可以使用不等值连接或者使用or连接多个条件。</p><pre><code>select a.* from shop a full outer join sale_detail b on a.shop_name=b.shop_name        full outer join sale_detail c on a.shop_name=c.shop_name;    -- 支持多路join链接示例select a.* from shop a join sale_detail b on a.shop_name != b.shop_name;    -- 不支持不等值Join链接条件，报错返回。</code></pre><h3 id="IMPLICIT-JOIN"><a href="#IMPLICIT-JOIN" class="headerlink" title="IMPLICIT JOIN"></a>IMPLICIT JOIN</h3><p>IMPLICIT JOIN，MaxCompute支持如下Join方式。</p><pre><code>SELECT * FROM table1, table2 WHERE table1.id = table2.id;--执行的效果相当于SELECT * FROM table1 JOIN table2 ON table1.id = table2.id;s</code></pre>]]></content>
      
      
      <categories>
          
          <category> Maxcompute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maxcompute-Select </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>105-内建函数-字符串函数</title>
      <link href="/2018/12/11/05%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0(%E5%BE%85%E7%BB%AD)/"/>
      <url>/2018/12/11/05%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0(%E5%BE%85%E7%BB%AD)/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><h4 id="CHAR-MATCHCOUNT"><a href="#CHAR-MATCHCOUNT" class="headerlink" title="CHAR_MATCHCOUNT"></a>CHAR_MATCHCOUNT</h4><pre><code>bigint char_matchcount(string str1, string str2)</code></pre><p>命令说明如下：</p><p>该函数用于计算str1中有多少个字符出现在str2中。</p><p>参数说明：</p><ul><li>str1，str2：String类型，必须为有效的UTF-8字符串，如果对比中发现有无效字符则函数返回负值。</li><li>bigint：返回值为bigint类型。任一输入为NULL返回NULL。<br>示例如下：</li></ul><pre><code>char_matchcount(&#39;abd&#39;,&#39;aabc&#39;) = 2-- str1中得两个字符串&#39;a&#39;,&#39;b&#39;在str2中出现过</code></pre><h4 id="CHR"><a href="#CHR" class="headerlink" title="CHR"></a>CHR</h4><pre><code>string chr(bigint ascii)</code></pre><p>命令说明如下：</p><p>该函数用于将给定ASCII码ascii转换成字符。</p><p>参数说明：<br>ascii：Bigint类型ASCII值，若输入为String类型或Double类型或Decimal类型会隐式转换到Bigint类型后参与运算，其它类型抛异常。<br>String：返回值为String类型。参数范围是0~255，超过此范围会引发异常。输入值为NULL返回NULL。</p><h4 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT"></a>CONCAT</h4><pre><code>string concat(string a, string b...)</code></pre><p>命令说明如下：</p><p>该函数的返回值是将参数中的所有字符串连接在一起的结果。</p><p>参数说明：<br>a，b等为String类型，若输入为Bigint，Double，Decimal或者Datetime类型会隐式转换为String后参与运算，其它类型报异常。<br>String：返回值为String类型。如果没有参数或者某个参数为NULL，结果均返回NULL。</p><pre><code>concat(&#39;ab&#39;,&#39;c&#39;) = &#39;abc&#39;concat() = NULLconcat(&#39;a&#39;, null, &#39;b&#39;) = NULL</code></pre><h4 id="GET-JSON-OBJECT"><a href="#GET-JSON-OBJECT" class="headerlink" title="GET_JSON_OBJECT"></a>GET_JSON_OBJECT</h4><pre><code>STRING GET_JSON_OBJECT(STRING json,STRING path)</code></pre><blockquote><p>该函数用于在一个标准JSON字符串中，按照path抽取指定的字符串。每次调用该函数时，都会读一次原始数据，因此反复调用可能会造成性能和费用的浪费。利用GET_JSON_OBJECT结合UDTF，您可以轻松转换JSON格式日志数据，避免多次调用函数</p></blockquote><p>参数说明：</p><ul><li>json： String类型，标准的json格式字符串。</li><li>path：String类型，用于描述在json中的path，以$开头。关于新实现中json path的说明，请参见：LanguageManual UDF。<ul><li>$ : 表示根节点</li><li>. : 表示child</li><li>[] : [number]表示数组下标，对于数组，格式为key[sub1][sub2][sub3]……</li><li><ul><li>: Wildcard for []，返回整个数组，*不支持转义</li></ul></li></ul></li><li>String：返回值为String类型。</li></ul><p>示例一如下：</p><pre><code>+----+json+----+{&quot;store&quot;:{&quot;fruit&quot;:[{&quot;weight&quot;:8,&quot;type&quot;:&quot;apple&quot;},{&quot;weight&quot;:9,&quot;type&quot;:&quot;pear&quot;}],&quot;bicycle&quot;:{&quot;price&quot;:19.95,&quot;color&quot;:&quot;red&quot;}},&quot;email&quot;:&quot;amy@only_for_json_udf_test.net&quot;,&quot;owner&quot;:&quot;amy&quot;}</code></pre><p>通过以下查询，可以提取json对象中的信息：</p><pre><code>odps&gt; SELECT get_json_object(src_json.json, &#39;$.owner&#39;) FROM src_json;amyodps&gt; SELECT get_json_object(src_json.json, &#39;$.store.fruit\[0]&#39;) FROM src_json;{&quot;weight&quot;:8,&quot;type&quot;:&quot;apple&quot;}odps&gt; SELECT get_json_object(src_json.json, &#39;$.non_exist_key&#39;) FROM src_json;NULL</code></pre><p>示例二如下：</p><pre><code>get_json_object(&#39;{&quot;array&quot;:[[&quot;aaaa&quot;,1111],[&quot;bbbb&quot;,2222],[&quot;cccc&quot;,3333]]}&#39;,&#39;$.array[1][1]&#39;)= &quot;2222&quot;get_json_object(&#39;{&quot;aaa&quot;:&quot;bbb&quot;,&quot;ccc&quot;:{&quot;ddd&quot;:&quot;eee&quot;,&quot;fff&quot;:&quot;ggg&quot;,&quot;hhh&quot;:[&quot;h0&quot;,&quot;h1&quot;,&quot;h2&quot;]},&quot;iii&quot;:&quot;jjj&quot;}&#39;,&#39;$.ccc.hhh[*]&#39;) = &quot;[&quot;h0&quot;,&quot;h1&quot;,&quot;h2&quot;]&quot;get_json_object(&#39;{&quot;aaa&quot;:&quot;bbb&quot;,&quot;ccc&quot;:{&quot;ddd&quot;:&quot;eee&quot;,&quot;fff&quot;:&quot;ggg&quot;,&quot;hhh&quot;:[&quot;h0&quot;,&quot;h1&quot;,&quot;h2&quot;]},&quot;iii&quot;:&quot;jjj&quot;}&#39;,&#39;$.ccc.hhh[1]&#39;) = &quot;h1&quot;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Maxcompute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maxcompute-内建函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>104-内建函数-聚合函数</title>
      <link href="/2018/12/10/04%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/10/04%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>聚合函数，其输入与输出是多对一的关系，即将多条输入记录聚合成一条输出值。可以与SQL中的group by语句联用。</p><h4 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h4><pre><code>bigint count([distinct|all] value)</code></pre><p>命令说明如下：</p><p>该函数用于计算记录数。</p><p>参数说明：</p><ul><li>distinct|all：指明在计数时是否去除重复记录，默认是all，即计算全部记录，如果指定distinct，则可以只计算唯一值数量。</li><li>value：可以为任意类型，当value值为NULL时，该行不参与计算，value可以为<em>，当count(</em>) 时，返回所有行数。<br>返回值：</li></ul><p>返回Bigint类型。</p><p>示例如下：</p><pre><code>-- 如表tbla有列col1类型为 Bigint+------+| COL1 |+------+| 1 |+------+| 2 |+------+| NULL |+------+select count(*) from tbla; -- 值为3,select count(col1) from tbla; -- 值为2</code></pre><blockquote><p>聚合函数可以和group by一同使用，例如：假设存在表test_src，存在如下两列：key string类型，value double类型。</p></blockquote><pre><code>-- test_src的数据为+-----+-------+| key | value |+-----+-------+| a | 2.0 |+-----+-------+| a | 4.0 |+-----+-------+| b | 1.0 |+-----+-------+| b | 3.0 |+-----+-------+-- 此时执行如下语句，结果为：select key, count(value) as count from test_src group by key;+-----+-------+| key | count |+-----+-------+| a | 2 |+-----+-------+| b | 2 |+-----+-------+-- 聚合函数将对相同key值得value值做聚合计算。下面介绍的其他聚合函数使用方法均与此例相同，不一一举例。</code></pre><h4 id="AVG"><a href="#AVG" class="headerlink" title="AVG"></a>AVG</h4><pre><code>double avg(double value)decimal avg(decimal value)</code></pre><p>命令说明如下：</p><p>该函数用于计算平均值。</p><p>参数说明：</p><p>value：Double类型或Decimal 类型，若输入为String或Bigint，会隐式转换到Double类型后参与运算，其它类型抛异常。当value值为NULL 时，该行不参与计算。Boolean类型不允许参与计算。</p><p>返回值：</p><p>若输入Decimal类型，返回Decimal类型，其他合法输入类型返回Double类型。</p><p>示例如下：  </p><pre><code>-- 如表tbla有一列value，类型为 Bigint+-------+| value |+-------+| 1 || 2 || NULL |+-------+-- 则对该列计算avg结果为(1+2)/2=1.5select avg(value) as avg from tbla;+------+| avg |+------+| 1.5 |+------+</code></pre><h4 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h4><pre><code>max(value)</code></pre><p>命令说明如下：</p><p>该函数用于计算最大值。</p><p>参数说明：</p><p>value：可以为任意类型，当列中的值为NULL时，该行不参与计算。Boolean类型不允许参与运算。</p><p>返回值：</p><p>返回值的类型与value类型相同。</p><p>示例如下：</p><pre><code>-- 如表tbla有一列col1，类型为 Bigint+------+| col1 |+------+| 1 |+------+| 2 |+------+| NULL |+------+select max(value) from tbla; -- 返回值为2</code></pre><h4 id="MIN"><a href="#MIN" class="headerlink" title="MIN"></a>MIN</h4><pre><code>MIN(value)</code></pre><p>该函数用于计算最小值。</p><h4 id="MEDIAN"><a href="#MEDIAN" class="headerlink" title="MEDIAN"></a>MEDIAN</h4><pre><code>double median(double number)decimal median(decimal number)</code></pre><p>该函数用于计算中位数。</p><h4 id="STDDEV"><a href="#STDDEV" class="headerlink" title="STDDEV"></a>STDDEV</h4><pre><code>double stddev(double number)decimal stddev(decimal number)</code></pre><p>该函数用于计算总体标准差。</p><pre><code>-- 如表tbla有一列value，类型为 Bigint+------+| value|+------+| 1 |+------+| 2 |+------+| 3 |+------+| 4 |+------+| 5 |+------+select STDDEV(value) from tbla; -- 返回值为 1.4142135623730951</code></pre><h4 id="STDDEV-SAMP"><a href="#STDDEV-SAMP" class="headerlink" title="STDDEV_SAMP"></a>STDDEV_SAMP</h4><pre><code>double stddev_samp(double number)decimal stddev_samp(decimal number)</code></pre><p>该函数用于计算样本标准差。</p><p>示例如下：</p><pre><code>-- 如表tbla有一列value，类型为 Bigint+------+| value|+------+| 1 |+------+| 2 |+------+| 3 |+------+| 4 |+------+| 5 |+------+select STDDEV_SAMP(value) from tbla; -- 返回值为 1.5811388300841898</code></pre><h4 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h4><pre><code>sum(value)</code></pre><p>该函数用于计算汇总值。</p><p>示例如下：</p><pre><code>-- 如表tbla有一列value，类型为 Bigint+------+| value|+------+| 1 |+------+| 2 |+------+| NULL |+------+select sum(value) from tbla; -- 返回值为3</code></pre><h4 id="WM-CONCAT"><a href="#WM-CONCAT" class="headerlink" title="WM_CONCAT"></a>WM_CONCAT</h4><pre><code>string wm_concat(string separator, string str</code></pre><p>命令说明如下：</p><p>该函数用指定的spearator做分隔符，链接str中的值。</p><p>参数说明：<br>separator：String类型常量，分隔符。其他类型或非常量将引发异常。<br>str：String类型，若输入为Bigint，Double或者Datetime类型，会隐式转换为String后参与运算，其它类型报异常。<br>返回值：</p><p>返回String类型。</p><blockquote><p>语句select wm_concat(‘,’, name) from test_src;中，若test_src为空集合，此条语句返回NULL值。</p></blockquote><h4 id="COLLECT-LIST"><a href="#COLLECT-LIST" class="headerlink" title="COLLECT_LIST"></a>COLLECT_LIST</h4><pre><code>ARRAY collect_list(col)</code></pre><p>命令说明如下：</p><p>该函数在给定group内，将col指定的表达式聚合为一个数组。</p><p>参数说明：</p><p>col：表的某列，可为任意数据类型。</p><p>返回值：</p><p>返回ARRAY类型。</p><h4 id="COLLECT-SET"><a href="#COLLECT-SET" class="headerlink" title="COLLECT_SET"></a>COLLECT_SET</h4><pre><code>ARRAY collect_set(col)</code></pre><p>命令说明如下：</p><p>该函数在给定group内，将col指定的表达式聚合为一个无重复元素的集合数组。</p><p>参数说明：</p><p>col：表的某列，可为任意数据类型。</p><p>返回值：</p><p>返回ARRAY类型。</p><h3 id="S28新函数"><a href="#S28新函数" class="headerlink" title="S28新函数"></a>S28新函数</h3><h4 id="VARIANCE-VAR-POP"><a href="#VARIANCE-VAR-POP" class="headerlink" title="VARIANCE/VAR_POP"></a>VARIANCE/VAR_POP</h4><pre><code>DOUBLE variance(col)DOUBLE var_pop(col)</code></pre><p>命令说明如下：</p><p>该函数用于求指定数字列的方差。</p><p>参数说明：</p><p>col：数值类型列，其他类型返回null。</p><p>返回值：</p><p>返回double类型。</p><p>示例如下：</p><p>test表的c1列数据如下所示：</p><pre><code>+------------+| c1 |+------------+| 8 || 9 || 10 || 11 |+------------+</code></pre><p>执行下述语句求该表c1列的方差。</p><pre><code>select variance(c1) from test;--或select var_pop(c1) from test;--执行结果如下：+------------+| _c0 |+------------+| 1.25 |+------------+</code></pre><h4 id="VAR-SAMP"><a href="#VAR-SAMP" class="headerlink" title="VAR_SAMP"></a>VAR_SAMP</h4><pre><code>DOUBLE var_samp(col)</code></pre><p>命令说明如下：</p><p>该函数用于求指定数字列的样本方差。</p><p>参数说明：</p><p>col：数值类型列，其他类型返回null。</p><p>返回值：</p><p>返回double类型。</p><p>示例如下：</p><p>test表的c1列数据如下所示：</p><pre><code>+------------+| c1 |+------------+| 8 || 9 || 10 || 11 |+------------+</code></pre><p>执行下述语句求该表c1列的方差。</p><pre><code>select var_samp(c1) from test;--执行结果如下：+------------+| _c0 |+------------+| 1.6666666666666667 |+------------+</code></pre><h4 id="COVAR-POP"><a href="#COVAR-POP" class="headerlink" title="COVAR_POP"></a>COVAR_POP</h4><pre><code>DOUBLE covar_pop(col1, col2)</code></pre><p>命令说明如下：</p><p>该函数用于求指定两个数字列的总体协方差。</p><p>参数说明：</p><p>col1/col2：数值类型列，其他类型返回null。</p><p>示例如下：</p><pre><code>+------------+------------+| c1 | c2 |+------------+------------+| 3 | 2 || 14 | 5 || 50 | 14 || 26 | 75 |+------------+------------+</code></pre><p>执行下述语句求c1，c2的总体协方差。</p><pre><code>select covar_pop(c1,c2) from test;--结果如下：+------------+| _c0 |+------------+| 123.49999999999997|+------------+</code></pre><h4 id="COVAR-SAMP"><a href="#COVAR-SAMP" class="headerlink" title="COVAR_SAMP"></a>COVAR_SAMP</h4><pre><code>DOUBLE covar_samp(col1, col2)</code></pre><p>命令说明如下：</p><p>该函数用于求指定两个数字列的样本协方差。</p><p>参数说明：</p><p>col1/col2：数字类型列，其他类型返回null。</p><p>示例如下：</p><p>test表（c1 bigint，c2 bigint）数据如下所示:</p><pre><code>+------------+------------+| c1 | c2 |+------------+------------+| 3 | 2 || 14 | 5 || 50 | 14 || 26 | 75 |+------------+------------+</code></pre><p>执行下述语句求c1，c2的样本协方差。</p><pre><code>select covar_samp(c1,c2) from test;--结果如下：+------------+| _c0 |+------------+| 164.66666666666663|+------------+</code></pre><h4 id="PERCENTILE"><a href="#PERCENTILE" class="headerlink" title="PERCENTILE"></a>PERCENTILE</h4><pre><code>DOUBLE percentile(BIGINT col, p)array percentile(BIGINT col, array(p1 [, p2]...))</code></pre><p>命令说明如下：</p><p>返回指定列精确的第p位百分数，p必须在0和1之间。</p><p>参数说明：</p><ul><li>col：bigint类型。</li><li>p：必须是大于等0小于等于1。<br>示例如下：</li></ul><p>test表的c1列数据如下所示：</p><pre><code>+------------+| c1 |+------------+| 8 || 9 || 10 || 11 |+------------+</code></pre><p>执行下述语句求该表c1列的第P位百分数。</p><pre><code>select percentile(c1,0),percentile(c1,0.3),percentile(c1,0.5),percentile(c1,1) from var_test;--执行结果如下：+------------+------------+------------+------------+| _c0 | _c1 | _c2 | _c3 |+------------+------------+------------+------------+| 8.0 | 8.9 | 9.5 | 11.0 |+------------+------------+------------+------------+--执行select percentile(c1,array(0,0.3,0.5,1))from var_test;结果如下：+------+| _c0 |+------+| [8, 8.9, 9.5, 11] |+------+</code></pre>]]></content>
      
      
      <categories>
          
          <category> Maxcompute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maxcompute-内建函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>103-内建函数-窗口函数</title>
      <link href="/2018/12/09/03%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/09/03%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h3><ul><li>只能出现在select子句中</li><li>目前在一个MaxCompute SQL语句中，最多可以使用5个窗口函数。</li><li>窗口函数中不要嵌套使用窗口函数和聚合函数</li><li>窗口函数不可以和同级别的聚合函数一起使用</li></ul><h3 id="语法声明"><a href="#语法声明" class="headerlink" title="语法声明"></a>语法声明</h3><pre><code>window_func() over (partition by [col1,col2…][order by [col1[asc|desc], col2[asc|desc]…]] windowing_clause)</code></pre><ul><li>partition by部分用来指定开窗的列。分区列的值相同的行被视为在同一个窗口内。现阶段，同一窗口内最多包含1亿行数据（建议不超过500万行），否则运行时报错。</li><li>order by用来指定数据在一个窗口内如何排序。</li><li><p>windowing_clause部分可以用rows指定开窗方式，有以下两种方式：</p><blockquote><p>rows between x preceding|following and y preceding|following表示窗口范围是从前或后x行到前或后y行。</p></blockquote><blockquote><p>rows x preceding|following窗口范围是从前或后第x行到当前行。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Maxcompute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maxcompute-内建函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>102-内建函数-数学函数</title>
      <link href="/2018/12/08/02%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/"/>
      <url>/2018/12/08/02%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><h4 id="ABS"><a href="#ABS" class="headerlink" title="ABS"></a>ABS</h4><pre><code>Double abs(Double number)Bigint abs(Bigint number)Decimal abs(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于返回number的绝对值。</p><p>参数说明：</p><p>number：当number为Double、Bigint或Decimal类型时。</p><ul><li>输入为Bigint，返回Bigint。</li><li>输入为Double，返回Double类型。</li><li>输入为Decimal，返回Decimal类型。<br>若输入为String类型，会隐式转换为Double类型后参与运算，其它类型抛异常。</li></ul><p>返回值：</p><p>返回Double、Bigint或Decimal类型，取决于输入参数的类型。若输入为null，则返回null。</p><p>示例如下：</p><pre><code>abs(null)=nullabs(-1)=1abs(-1.2)=1.2abs(&quot;-2&quot;)=2.0abs(122320837456298376592387456923748)=1.2232083745629837e32#完整的ABS函数在SQL中的使用select abs(id) from tbl1;-- 取tbl1表内id字段的绝对值</code></pre><h4 id="ACOS"><a href="#ACOS" class="headerlink" title="ACOS"></a>ACOS</h4><pre><code>Double acos(Double number)Decimal acos(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的反余弦函数。</p><p>参数说明：</p><ul><li>number：Double类型或Decimal类型，-1 ≤ number ≤1。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</li></ul><p>返回值：</p><p>返回Double类型或Decimal类型，值域在0 ~ π之间。若number为null，则返回null。</p><pre><code>acos(&quot;0.87&quot;)=0.5155940062460905acos(0)=1.5707963267948966</code></pre><h4 id="ASIN"><a href="#ASIN" class="headerlink" title="ASIN"></a>ASIN</h4><pre><code>Double asin(Double number)Decimal asin(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的反正弦函数。</p><p>参数说明：</p><ul><li>number：Double类型或Decimal类型，-1 ≤ number ≤1。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</li></ul><p>返回值：</p><p>返回Double类型或Decimal类型，值域在-π/2 ~π/2之间。若number为null，返回null。</p><pre><code>asin(1)=1.5707963267948966asin(-1)=-1.5707963267948966</code></pre><h4 id="ATAN"><a href="#ATAN" class="headerlink" title="ATAN"></a>ATAN</h4><pre><code>Double atan(Double number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的反正切函数。</p><p>参数说明：</p><ul><li>number：Double类型，若输入为String类型或Bigint类型，会隐式转换到Double类型后参与运算，其他类型抛异常。</li></ul><p>返回值：</p><p>返回Double类型，值域在-π/2~π/2之间。若number为null，则返回null。</p><pre><code>atan(1)=0.7853981633974483atan(-1)=-0.7853981633974483</code></pre><h4 id="CEIL"><a href="#CEIL" class="headerlink" title="CEIL"></a>CEIL</h4><pre><code>Bigint ceil(Double value)Bigint ceil(Decimal value)</code></pre><p>命令说明如下：</p><p>向上取整，函数返回不小于输入值value的最小整数。</p><p>参数说明：</p><p>value：Double类型或Decimal类型，若输入为String类型或Bigint类型，会隐式转换到Double类型后参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Bigint类型。任意一个参数输入为null，则返回null。</p><pre><code>ceil(1.1)=2ceil(-1.1)=-1</code></pre><h4 id="CONV"><a href="#CONV" class="headerlink" title="CONV"></a>CONV</h4><pre><code>String conv(String input, Bigint from_base, Bigint to_base)</code></pre><p>命令说明如下：</p><p>该函数为进制转换函数。</p><p>参数说明：</p><ul><li>input：以String表示的要转换的整数值，接受Bigint、Double的隐式转换。</li><li>from_base、to_base：以十进制表示的进制的值，可接受的的值为2、8、10和16。接受String及Double的隐式转换。</li></ul><p>返回值：</p><p>返回String类型。任意一个参数输入为null，返回null。转换过程以64位精度工作，溢出时报异常。输入如果是负值，即以（-）开头，报异常。如果输入的是小数，则会转为整数值后进行进制转换，小数部分会被舍弃。</p><pre><code>conv(&#39;1100&#39;, 2, 10)=&#39;12&#39;conv(&#39;1100&#39;, 2, 16)=&#39;c&#39;conv(&#39;ab&#39;, 16, 10)=&#39;171&#39;conv(&#39;ab&#39;, 16, 16)=&#39;ab&#39;</code></pre><h4 id="COS"><a href="#COS" class="headerlink" title="COS"></a>COS</h4><pre><code>Double cos(Double number)Decimal cos(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的余弦函数，输入为弧度值。</p><p>参数说明：</p><ul><li>number：Double类型或Decimal类型。若输入为String类型或Bigint类型，会隐式转换到Double类型后参与运算，其他类型抛异常。</li></ul><p>返回值：</p><p>返回Double类型或Decimal类型。若number为null，则返回null。</p><pre><code>cos(3.1415926/2)=2.6794896585028633e-8cos(3.1415926)=-0.9999999999999986</code></pre><h4 id="COSH"><a href="#COSH" class="headerlink" title="COSH"></a>COSH</h4><pre><code>Double cosh(Double number)Decimal cosh(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的双曲余弦函数。</p><p>参数说明：</p><p>number：Double类型或Decimal类型。若输入为String类型或Bigint类型，会隐式转换为Double类型后，参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Double类型或Decimal类型。若number为null，返回null。</p><h4 id="COT"><a href="#COT" class="headerlink" title="COT"></a>COT</h4><pre><code>Double cot(Double number)Decimal cot(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的余切函数，输入为弧度值。</p><p>参数说明：</p><p>number：Double类型或Decimal类型。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Double类型或Decimal类型。若number为null，则返回null。</p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><pre><code>Double exp(Double number)Decimal exp(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的指数函数。</p><p>返回值：</p><p>返回number的指数值。</p><p>参数说明：</p><p>number：Double类型或Decimal类型。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Double类型或Decimal类型。若number为null，则返回null。</p><h4 id="FLOOR"><a href="#FLOOR" class="headerlink" title="FLOOR"></a>FLOOR</h4><pre><code>Bigint floor(Double number)Bigint floor(Decimal number)</code></pre><p>命令说明如下：</p><p>向下取整，函数返回不大于number的最大整数值。</p><p>参数说明：</p><p>number：Double类型或Decimal类型，若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Bigint类型。若number为null，则返回null。</p><pre><code>floor(1.2)=1floor(1.9)=1floor(0.1)=0floor(-1.2)=-2floor(-0.1)=-1floor(0.0)=0floor(-0.0)=0</code></pre><h4 id="LN"><a href="#LN" class="headerlink" title="LN"></a>LN</h4><pre><code>Double ln(Double number)Decimal ln(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于返回number的自然对数。</p><p>参数说明：</p><p>number：Double类型或Decimal类型。</p><ul><li>若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</li><li>若number为null，则返回null。若number为负数或零，则执行报错。<br>返回值：</li></ul><p>返回Double类型或Decimal类型。</p><h4 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h4><pre><code>Double log(Double base, Double x)Decimal log(Decimal base, Decimal x)</code></pre><p>命令说明如下：</p><p>该函数用于返回以base为底的x的对数。</p><p>参数说明：</p><ul><li>base：Double类型或Decimal类型，若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</li><li>x：Double类型或Decimal类型，若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</li></ul><p>返回值：</p><p>返回Double类型或Decimal类型的对数值。</p><ul><li>若base和x中存在null，则返回null。</li><li>若base和x中某一个值为负数或 0，会引发异常。</li><li>若base为1（会引发一个除零行为），也会引发异常。</li></ul><h4 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h4><pre><code>Double pow(Double x, Double y)Decimal pow(Decimal x, Decimal y)</code></pre><p>命令说明如下：</p><p>该函数用于返回x的y次方，即x^y。</p><p>参数说明：</p><ul><li>X：Double类型或Decimal类型，若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</li><li>Y：Double类型或Decimal类型，若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。<br>返回值：</li></ul><p>返回Double类型或Decimal类型。若x或y为null，则返回null。</p><h4 id="RAND"><a href="#RAND" class="headerlink" title="RAND"></a>RAND</h4><pre><code>Double rand(Bigint seed)</code></pre><p>命令说明如下：</p><p>该函数以seed为种子，返回Double类型的随机数，返回值区间是的0～1。</p><p>参数说明：</p><p>seed：可选参数，Bigint类型，随机数种子，决定随机数序列的起始值。</p><p>返回值：</p><p>返回Double类型。</p><p>示例如下：</p><pre><code>select rand() from dual;select rand(1) from dual;</code></pre><h4 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND"></a>ROUND</h4><pre><code>Double round(Double number, [Bigint Decimal_places])Decimal round(Decimal number, [Bigint Decimal_places])</code></pre><p>命令说明如下：</p><p>该函数四舍五入到指定小数点位置。</p><p>参数说明：</p><ul><li>number：Double类型或Decimal类型。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</li><li>Decimal_place：Bigint类型常量，四舍五入计算到小数点后的位置，其他类型参数会引发异常。如果省略表示四舍五入到个位数，默认值为0。<br>返回值：</li></ul><p>返回Double类型或Decimal类型。若number或Decimal_places为null，则返回null。</p><pre><code>round(125.315)=125.0round(125.315, 0)=125.0round(125.315, 1)=125.3round(125.315, 2)=125.32round(125.315, 3)=125.315round(-125.315, 2)=-125.32round(123.345, -2)=100.0round(null)=nullround(123.345, 4)=123.345round(123.345, -4)=0.0</code></pre><h4 id="SIN"><a href="#SIN" class="headerlink" title="SIN"></a>SIN</h4><pre><code>Double sin(Double number)Decimal sin(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的正弦函数，输入为弧度值。</p><p>参数说明：</p><p>number：Double类型或Decimal类型。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Double类型或Decimal类型。若number为null，则返回null。</p><h4 id="SINH"><a href="#SINH" class="headerlink" title="SINH"></a>SINH</h4><pre><code>Double sinh(Double number)Decimal sinh(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的双曲正弦函数。</p><p>参数说明：</p><p>number：Double类型或Decimal类型。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Double类型或Decimal类型。若number为null，则返回null。</p><h4 id="SQRT"><a href="#SQRT" class="headerlink" title="SQRT"></a>SQRT</h4><pre><code>Double sqrt(Double number)Decimal sqrt(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的平方根。</p><p>参数说明：</p><p>number：Double类型或Decimal类型，必须大于0，小于0时引发异常。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Double类型或Decimal类型。若number为null，则返回null。</p><h4 id="TANH"><a href="#TANH" class="headerlink" title="TANH"></a>TANH</h4><pre><code>Double tanh(Double number)Decimal tanh(Decimal number)</code></pre><p>命令说明如下：</p><p>该函数用于计算number的双曲正切函数。</p><p>参数说明：</p><p>number：Double类型或Decimal类型。若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</p><p>返回值：</p><p>返回Double类型或Decimal类型。若number为null，则返回null。</p><h4 id="TRUNC"><a href="#TRUNC" class="headerlink" title="TRUNC"></a>TRUNC</h4><pre><code>Double trunc(Double number[, Bigint Decimal_places])Decimal trunc(Decimal number[, Bigint Decimal_places])</code></pre><p>命令说明如下：</p><p>该函数用于将输入值number截取到指定小数点位置。</p><p>参数说明：</p><ul><li>number：Double类型或Decimal类型，若输入为String类型或Bigint类型，会隐式转换为Double类型后参与运算，其他类型抛异常。</li><li>Decimal_places：Bigint类型常量，要截取到的小数点位置，其他类型参数会隐式转为Bigint，省略此参数时默认到截取到个位数。<br>返回值：</li></ul><p>返回值类型为Double或Decimal类型。若number或Decimal_places为null，则返回null。</p><pre><code>trunc(125.815)=125.0trunc(125.815,0)=125.0trunc(125.815,1)=125.80000000000001trunc(125.815,2)=125.81trunc(125.815,3)=125.815trunc(-125.815,2)=-125.81trunc(125.815,-1)=120.0trunc(125.815,-2)=100.0trunc(125.815,-3)=0.0trunc(123.345,4)=123.345trunc(123.345,-4)=0.0</code></pre>]]></content>
      
      
      <categories>
          
          <category> Maxcompute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maxcompute-内建函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>101-内建函数-日期函数</title>
      <link href="/2018/09/07/01%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0/"/>
      <url>/2018/09/07/01%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0-%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><a href="https://helpcdn.aliyun.com/document_detail/96342.html?spm=a2c4g.11186623.6.642.5ced5c813MwBoQ" target="_blank" rel="noopener">内建函数对照-与mysql 以及oracle</a></p><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><h4 id="DATEADD"><a href="#DATEADD" class="headerlink" title="DATEADD"></a>DATEADD</h4><pre><code>datetime dateadd(datetime date, bigint delta, string datepart)</code></pre><ul><li>date：Datetime类型，日期值。若输入为String类型会隐式转换为Datetime类型后参与运算，其它类型抛异常。</li><li>delta：Bigint类型，修改幅度。若输入为String类型或Double型会隐式转换到Bigint类型后参与运算，其他类型会引发异常。若delta大于0，则增，否则减。</li><li>datepart：String类型常量。此字段的取值遵循String与Datetime类型转换的约定，即yyyy表示年，mm表示月。<blockquote><p>关于类型转换的规则，请参见String类型与Datetime类型之间的转换。此外也支持扩展的日期格式：年-year，月-month或mon，日-day，小时-hour。非常量、不支持的格式或其它类型会抛异常。</p></blockquote></li></ul><pre><code>若trans_date = 2005-02-28 00:00:00：dateadd(trans_date, 1, &#39;dd&#39;) = 2005-03-01 00:00:00-- 加一天，结果超出当年2月份的最后一天，实际值为下个月的第一天dateadd(trans_date, -1, &#39;dd&#39;) = 2005-02-27 00:00:00-- 减一天dateadd(trans_date, 20, &#39;mm&#39;) = 2006-10-28 00:00:00-- 加20个月，月份溢出，年份加1若trans_date = 2005-02-28 00:00:00, dateadd(transdate, 1, &#39;mm&#39;) = 2005-03-28 00:00:00若trans_date = 2005-01-29 00:00:00, dateadd(transdate, 1, &#39;mm&#39;) = 2005-02-28 00:00:00-- 2005年2月没有29日，日期截取至当月最后一天若trans_date = 2005-03-30 00:00:00, dateadd(transdate, -1, &#39;mm&#39;) = 2005-02-28 00:00:00</code></pre><p>示例：将string类转换为datetime类型</p><blockquote><p>错误示例：select dateadd(2005-03-30 00:00:00, -1, ‘mm’) from tbl1;</p></blockquote><blockquote><p>正确示例：select dateadd(cast(“2005-03-30 00:00:00” as datetime), -1, ‘mm’) from tbl1;</p></blockquote><h4 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF"></a>DATEDIFF</h4><pre><code>bigint datediff(datetime date1, datetime date2, string datepart)</code></pre><p>命令说明如下：</p><p>计算两个时间date1、date2在指定时间单位datepart的差值。</p><p>参数说明：</p><ul><li>datet1、date2：Datetime类型，被减数和减数，若输入为String类型会隐式转换为Datetime类型后参与运算，其它类型抛异常。</li><li>datepart：String类型常量。支持扩展的日期格式。若datepart不符合指定格式或者其它类型则会发生异常。</li></ul><p>返回值：</p><p>返回Bigint类型。任一输入参数是NULL，返回NULL。如果date1小于date2，返回值可以为负数。</p><p>示例如下：</p><pre><code>若start = 2005-12-31 23:59:59，end = 2006-01-01 00:00:00:    datediff(end, start, &#39;dd&#39;) = 1    datediff(end, start, &#39;mm&#39;) = 1    datediff(end, start, &#39;yyyy&#39;) = 1    datediff(end, start, &#39;hh&#39;) = 1    datediff(end, start, &#39;mi&#39;) = 1    datediff(end, start, &#39;ss&#39;) = 1    datediff(&#39;2013-05-31 13:00:00&#39;, &#39;2013-05-31 12:30:00&#39;, &#39;ss&#39;) = 1800    datediff(&#39;2013-05-31 13:00:00&#39;, &#39;2013-05-31 12:30:00&#39;, &#39;mi&#39;) = 30若start = 2018-06-04 19:33:23.234，end = 2018-06-04 19:33:23.250 含毫秒的日期不属于标准Datetime式样，不能直接隐式转换，此处需进行显示转换： datediff(to_date(&#39;2018-06-04 19:33:23.250&#39;, &#39;yyyy-MM-dd hh:mi:ss.ff3&#39;),to_date(&#39;2018-06-04 19:33:23.234&#39;, &#39;yyyy-MM-dd hh:mi:ss.ff3&#39;) , &#39;ff3&#39;) = 16</code></pre><h4 id="DATEPART"><a href="#DATEPART" class="headerlink" title="DATEPART"></a>DATEPART</h4><pre><code>bigint datepart(datetime date, string datepart)</code></pre><p>命令说明如下：</p><p>提取日期date中指定的时间单位datepart的值。</p><p>参数说明：</p><p>返回值：</p><ul><li>date：Datetime类型，若输入为String类型会隐式转换为Datetime类型后参与运算，其它类型抛异常。<br>datepart：String类型常量，支持扩展的日期格式。* 若datepart不符合指定格式或者其它类型则会发生异常。</li></ul><p>返回Bigint类型。若任一输入参数为NULL，返回NULL。</p><p>示例如下：</p><pre><code>datepart(&#39;2013-06-08 01:10:00&#39;, &#39;yyyy&#39;)  =  2013datepart(&#39;2013-06-08 01:10:00&#39;, &#39;mm&#39;)  =  6</code></pre><h4 id="DATETRUNC"><a href="#DATETRUNC" class="headerlink" title="DATETRUNC"></a>DATETRUNC</h4><pre><code>datetime datetrunc (datetime date, string datepart)</code></pre><p>命令说明如下：</p><p>返回日期date被截取指定时间单位datepart后的日期值。</p><p>参数说明：</p><ul><li>date：Datetime类型，若输入为String类型会隐式转换为Datetime类型后参与运算，其它类型抛异常。</li><li>datepart：String类型常量，支持扩展的日期格式。若datepart不符合指定格式或者其它类型则会发生异常。</li></ul><p>返回值：</p><p>Datetime类型。任意一个参数为NULL时，返回NULL。</p><p>示例如下：</p><pre><code>datetrunc(&#39;2011-12-07 16:28:46&#39;, &#39;yyyy&#39;) = 2011-01-01 00:00:00datetrunc(&#39;2011-12-07 16:28:46&#39;, &#39;month&#39;) = 2011-12-01 00:00:00datetrunc(&#39;2011-12-07 16:28:46&#39;, &#39;DD&#39;) = 2011-12-07 00:00:00</code></pre><h4 id="GETDATE"><a href="#GETDATE" class="headerlink" title="GETDATE"></a>GETDATE</h4><pre><code>datetime getdate()</code></pre><p>命令说明如下：</p><p>获取当前系统时间。使用东八区时间作为MaxCompute标准时间。</p><p>返回值：</p><p>返回当前日期和时间，Datetime类型。</p><h4 id="ISDATE"><a href="#ISDATE" class="headerlink" title="ISDATE"></a>ISDATE</h4><pre><code>boolean isdate(string date, string format)</code></pre><p>命令说明如下：</p><p>判断一个日期字符串能否根据对应的格式串转换为一个日期值，如果转换成功，返回TRUE，否则返回FALSE。</p><p>参数说明：</p><ul><li>date：String格式的日期值，若输入为Bigint、Double、Decimal或Datetime类型，会隐式转换为String类型后参与运算，其它类型报异常。</li><li>format：String类型常量，不支持日期扩展格式。其它类型或不支持的格式会抛异常。如果format中出现多余的格式串，则只取第一个格式串对应的日期数值，其余的会被视为分隔符。如isdate(“1234-yyyy”, “yyyy-yyyy”)，会返回TRUE。<br>返回值：</li></ul><p>返回Boolean类型，如任意参数为NULL，返回NULL。</p><h5 id="LASTDAY"><a href="#LASTDAY" class="headerlink" title="LASTDAY"></a>LASTDAY</h5><pre><code>datetime lastday(datetime date)</code></pre><p>命令说明如下：</p><p>取date当月的最后一天，截取到天，时分秒部分为00:00:00。</p><p>参数说明：</p><ul><li>date：Datetime类型，若输入为String 类型，会隐式转换为Datetime类型后参与运算，其它类型报异常。</li></ul><p>返回值：</p><p>返回Datetime类型，如输入为NULL，返回NULL。</p><h4 id="TO-DATE"><a href="#TO-DATE" class="headerlink" title="TO_DATE"></a>TO_DATE</h4><pre><code>datetime to_date(string date, string format)</code></pre><p>命令说明如下：</p><p>用途：将一个format格式的字符串date转成日期值。</p><p>参数说明：</p><ul><li>date：String类型，要转换的字符串格式的日期值，若输入为Bigint、Double、Decimal或者Datetime类型，会隐式转换为String类型后参与运算，为其它类型则抛异常，为空串时抛异常。</li><li>format：String类型常量，日期格式。非常量或其他类型会引发异常。format不支持日期扩展格式，其他字符作为无用字符在解析时忽略。</li></ul><blockquote><p>format参数至少包含“yyyy”，否则引发异常，如果format中出现多余的格式串，则只取第一个格式串对应的日期数值，其余的会被视为分隔符。如to_date(“1234-2234”, “yyyy-yyyy”) 会返回1234-01-01 00:00:00。</p></blockquote><blockquote><p>format格式：yyyy为四位数的年，mm为2位数的月，dd为2位数的日，hh为24小时制的时，mi为2位数的分钟，ss为2位数秒，ff3为3位精度毫秒。</p></blockquote><p>返回值：返回Datetime类型，格式为‘yyyy-mm-dd hh:mi:ss’ 。若任意一个输入的参数为NULL，则返回NULL值。</p><p>示例如下：</p><pre><code>to_date(&#39;阿里巴巴2010-12*03&#39;, &#39;阿里巴巴yyyy-mm*dd&#39;) = 2010-12-03 00:00:00to_date(&#39;20080718&#39;, &#39;yyyymmdd&#39;) = 2008-07-18 00:00:00to_date(&#39;200807182030&#39;,&#39;yyyymmddhhmi&#39;) = 2008-07-18 20:30:00to_date(&#39;2008718&#39;, &#39;yyyymmdd&#39;) = null-- 格式不符合，引发异常to_date(&#39;阿里巴巴2010-12*3&#39;, &#39;阿里巴巴yyyy-mm*dd&#39;) = null-- 格式不符合，引发异常to_date(&#39;2010-24-01&#39;, &#39;yyyy&#39;) = null-- 格式不符合，引发异常to_date(&#39;20181030 15-13-12.345&#39;,&#39;yyyymmdd hh-mi-ss.ff3&#39;)=2018-10-30 15:13:12</code></pre><h4 id="TO-CHAR"><a href="#TO-CHAR" class="headerlink" title="TO_CHAR"></a>TO_CHAR</h4><pre><code>string to_char(datetime date, string format)</code></pre><p>命令说明如下：</p><p>将日期类型date按照format指定的格式转成字符串。</p><p>参数类型：</p><ul><li>date：Datetime类型，要转换的日期值，若输入为String类型，会隐式转换为Datetime类型后参与运算，其它类型抛异常。</li><li>format：String类型常量。非常量或其他类型会引发异常。format中的日期格式部分会被替换成相应的数据，其它字符直接输出。</li></ul><p>返回值：</p><p>返回String类型。若任意一个输入的参数为NULL，则返回NULL值。</p><p>示例如下：</p><pre><code>to_char(&#39;2010-12-03 00:00:00&#39;, &#39;阿里金融yyyy-mm*dd&#39;) = &#39;阿里金融2010-12*03&#39;to_char(&#39;2008-07-18 00:00:00&#39;, &#39;yyyymmdd&#39;) = &#39;20080718&#39; to_char(&#39;阿里巴巴2010-12*3&#39;, &#39;阿里巴巴yyyy-mm*dd&#39;) -- 引发异常to_char(&#39;2010-24-01&#39;, &#39;yyyy&#39;) -- 会引发异常to_char(&#39;2008718&#39;, &#39;yyyymmdd&#39;) -- 会引发异常</code></pre><h4 id="UNIX-TIMESTAMP"><a href="#UNIX-TIMESTAMP" class="headerlink" title="UNIX_TIMESTAMP"></a>UNIX_TIMESTAMP</h4><pre><code>bigint unix_timestamp(datetime date)</code></pre><p>命令说明如下：</p><p>将日期date转化为整型的unix格式的日期时间值。</p><p>参数说明：</p><ul><li>date：Datetime类型日期值，若输入为String类型，会隐式转换为Datetime类型后参与运算，其它类型抛异常。</li></ul><p>返回值：</p><p>返回Bigint类型，表示unix格式日期值，date为NULL时，返回NULL值。</p><h4 id="FROM-UNIXTIME"><a href="#FROM-UNIXTIME" class="headerlink" title="FROM_UNIXTIME"></a>FROM_UNIXTIME</h4><pre><code>datetime from_unixtime(bigint unixtime)</code></pre><p>命令说明如下：</p><p>将数字型的unix时间日期值unixtime转为日期值。</p><p>参数说明：</p><ul><li>unixtime：Bigint类型，秒数，unix格式的日期时间值，若输入为String、Double、Decimal类型会隐式转换为Bigint后参与运算。</li></ul><p>返回值：</p><p>返回Datetime类型的日期值，unixtime为NULL时，返回NULL。</p><p>示例如下：</p><pre><code>from_unixtime(123456789) = 1973-11-30 05:33:09</code></pre><h4 id="WEEKDAY"><a href="#WEEKDAY" class="headerlink" title="WEEKDAY"></a>WEEKDAY</h4><pre><code>bigint weekday (datetime date)</code></pre><p>命令说明如下：</p><p>返回date日期当前周的第几天。</p><p>参数说明：</p><ul><li>date：Datetime类型，若输入为String类型，会隐式转换为Datetime类型后参与运算，其它类型抛异常。</li></ul><p>返回值：</p><p>返回Bigint类型，若输入参数为NULL，返回NULL值。周一作为一周的第一天，返回值为0。其他日期依次递增，周日返回6。</p><h4 id="WEEKOFYEAR"><a href="#WEEKOFYEAR" class="headerlink" title="WEEKOFYEAR"></a>WEEKOFYEAR</h4><pre><code>bigint weekofyear(datetime date)</code></pre><p>命令说明如下：</p><p>返回日期date位于那一年的第几周。周一作为一周的第一天。</p><p>参数说明:</p><ul><li>date：Datetime类型日期值，若输入为String类型，会隐式转换为Datetime类型后参与运算，其它类型抛异常。</li></ul><p>返回值：</p><p>返回Bigint类型。若输入为NULL，返回NULL值</p><p>示例如下：</p><pre><code>select weekofyear(to_date(&quot;20141229&quot;, &quot;yyyymmdd&quot;)) from dual;  返回结果：  +------------+| _c0        |+------------+| 1          |+------------+ -虽然20141229属于2014年，但是这一周的大多数日期是在2015年，因此返回结果为1，表示是2015年的第一周。     select weekofyear(to_date(&quot;20141231&quot;, &quot;yyyymmdd&quot;)) from dual；--返回结果为1。   select weekofyear(to_date(&quot;20151229&quot;, &quot;yyyymmdd&quot;)) from dual；--返回结果为53。</code></pre><h3 id="日期函数扩展函数（支持MaxCompute2-0）"><a href="#日期函数扩展函数（支持MaxCompute2-0）" class="headerlink" title="日期函数扩展函数（支持MaxCompute2.0）"></a>日期函数扩展函数（支持MaxCompute2.0）</h3>]]></content>
      
      
      <categories>
          
          <category> Maxcompute </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maxcompute-内建函数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
